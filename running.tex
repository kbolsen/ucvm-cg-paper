
\section{Using UCVM}

\textcolor{green}{We should describe the API as well. In fact, all of these utilities were written in terms of the UCVM API. I'd actually say this is the preferred method for querying with UCVM as it allows the user to integrate UCVM directly in their application. For example, Scott is using the UCVM API directly in Cybershake (or was, as of a couple of years ago).}

\textcolor{green}{Also, I would remove command-lines and input config files from the descriptions here and in the next section. We can place specific use cases in the Examples section I added later in the document.}

\textcolor{green}{For each utility, we should implicitly answer four questions as a narrative. 1) What problem is this utility trying to solve? 2) How does this utility solve the problem? 3) What information does the user need to provide? 4) What does the utility output? For the input description, rather than providing a configuration file, I would use a table with the relevant parameters to the problem and a description of each (ignoring simple things like output file paths, number of processors, etc).}

\textcolor{green}{Using ucvm2mesh as an example, here's how I would answer the four questions:}

\textcolor{green}{1) Construction of a structured uniform mesh in a format consistent with the AWP-ODC and SORD simulation codes. }

\textcolor{green}{2) Given a user-provided 2D map projection (typically UTM-11), a lat/long geographic anchor point, desired mesh cell dimensions along x-y-z, step sizes, and rotation angle in the map projection, ucvm2mesh projects the geographic coordinates of the Earth's surface into the map projection, placing the origin of the mesh as the anchor point and discretizing the volume according to the provided dimensions and step size. For each point in the projected volume, ucvm2mesh determines the analous geographic point in terms of lat/long/depth and queries the underlying CVMs for the material properties. These material properties are then assigned to the mesh point. }

\textcolor{green}{3) Lat/long origin point, rotation angle, number of cells x-y-z, dx, 2D map projection, list of models to query. }

\textcolor{green}{4) Four binary formats are supported (IJK-12, IJK-20, IJK-32, and SORD). For IJK-12 formatted meshes, the output is a binary file consisting of a list of nx*ny*nz tuples. Each tuple contains three single precision floating point values $(V_p. V_s, \rho)$, representing the material properties for a point in the mesh, with the mesh coordinates given implicitly by the position of the tuple in the list. The tuples are arranged in x-y-z order. Similarly, for IJK-20, ...}

\textcolor{green}{Spinning the above answers into a narrative, we have enough formalism that we have fully specified the behavior of the utility while avoiding showing actual command-lines and output. The command lines may change in the future if the interface is refactored. But it's unlikely the underlying algorithm will change significantly.}

The UCVM platform offers a series of commands that can be used in sequence or in parallel. This section details the most relevant of these commands. The single-core commands can be run in any system where the platform has been successfully installed. The parallel commands, however, require a system where the standard Message Passing Interface (MPI) library and compilers are available. Single-core commands are useful to most users interested in exploring the properties of the regions covered by the models supported by the platform. On the other hand, advanced users needing to build large-scale (regional) materialized velocity models for earthquake modeling and simulation are the more likely to use the MPI commands. 

In either case, before calling on UCVM commands, the user needs to make sure the main package configuration file is in place and has the desired setup. This file is used by UCVM to identify which components will be used when executing the commands. That is, is the file where the paths to all configured models and maps are specified, as well as any model flags are defined. The UCVM installer sets up this file automatically during installation at the path location \texttt{\$UCVM\_DIR/conf/ucvm.conf}. However, there are a limited number of situations where a user will want to modify this file (e.g., to change a specific model's configuration). Figure \ref{fig:ucvm-config} shows an example of a configuration file in which the models CVM-S and CVM-H are enabled, along with the 1D and GTL models used in the background of CVM-H. The following sections enumerate the command-line utilities and functionality provided by UCVM.

\input{figure-ucvm-config}

\subsection{Single-Core Commands}

We include here a short description of the single-core commands that are most used, or that we believe are most useful to the majority of users. A complete description of all the single-core commands available in UCVM can be found in the documentation links provided in Table \ref{tab:manuals}.

\subsubsection{The \textup{\texttt{ucvm\_query}} command}

This is the core tool of UCVM for querying the models supported by UCVM. Any set of crustal and GTL velocity models may be selected and queried in order of preference. Points may be queried by longitude, latitude and depth or longitude, latitude and elevation. These coordinate conversions for a particular model are handled transparently \textcolor{red}{(Not sure of what this means, we need to check the wording here to be as clear as possible.)}. Here is an example of how to run this command.

\begin{lstlisting}[
	frame=none,
	basewidth={0.45em,0.4em},
	basicstyle=\ttfamily\footnotesize,breaklines=true,
	linewidth=0.98\columnwidth,xleftmargin=0.07\columnwidth,
	numbers=left,numberblanklines=true,numberstyle=\scriptsize\color{mylistingnclr}]
> ./ucvm_query -f $UCVM_DIR/conf/ucvm.conf -m cvms ????
\end{lstlisting}

Note that the location of the package configuration file needs to be passed to the command using the flag ``\texttt{-f}'' and that the model to be used is set with the ``\texttt{-m}'' flag. 

\subsubsection{The \textup{\texttt{basin\_query}} command}

The command \texttt{basin\_query} allows you to retrieve the depth at which a given \vs{}-threshold is first crossed. By default, the threshold value is set to be \vseq{1,000}, but that can easily be changed with the ``\texttt{-v}'' flag. Here is an example of this command for a \vs-threshold of 2,500~m/s. \textcolor{red}{we need to also put print the output of this query.}:

\begin{lstlisting}[
	frame=none,
	basewidth={0.45em,0.4em},
	basicstyle=\ttfamily\footnotesize,breaklines=true,
	linewidth=0.98\columnwidth,xleftmargin=0.07\columnwidth,
	numbers=left,numberblanklines=true,numberstyle=\scriptsize\color{mylistingnclr}]
> ./basin_query $UCVM_DIR/conf/ucvm.conf -m cvms -v 2500
\end{lstlisting}

\subsubsection{The \textup{\texttt{ucvm2mesh}} command}

This command generates a mesh or grid in either IJK-12, IJK-20, IJK-32, or SORD formats. The formats IJK-12, IJK-20, IJK-32, for instance, are used in discrete finite difference models for wave propagation simulations by the code \textcolor{red}{AWP-ODC (?) \citep{Cui_2010_Proc}}. SORD, on the other hand, is a finite element code used to simulate dynamic rupture processes. The \texttt{ucvm2mesh} takes as input a configuration file that is passed on as an argument using the flag ``\texttt{-f}''. This file specifies the model to be used, the region size, and the resolution of the mesh or grid. The following example shows how to execute this command.

\begin{lstlisting}[
	frame=none,
	basewidth={0.45em,0.4em},
	basicstyle=\ttfamily\footnotesize,breaklines=true,
	linewidth=0.98\columnwidth,xleftmargin=0.07\columnwidth,
	numbers=left,numberblanklines=true,numberstyle=\scriptsize\color{mylistingnclr}]
> ./ucvm2mesh -f ./ucvm2mesh_example.conf
\end{lstlisting}

\subsubsection{The \textup{\texttt{ucvm2etree}} command}

The command \texttt{ucvm2etree} builds a materialized model in the form of an etree database, which uses an octree unstructured mesh-like format that adjust octant sizes to a specific resolution based on the material properties in the CVM being used at every point in a given volume. Resulting etrees built using this command are stand-alone discrete representations of a given velocity mode, and can be used as input models for other operations using UCVM. They can also be queried separately using APIs distributed with the etree library. In wave propagation problems, etrees are used by the code Hercules \citep{Tu_2006_SC, Taborda_2010_Tech} in earthquake ground motion simulations. As in the previous case, this command takes an argument input configuration file. The following example shows how to execute this command.

\begin{lstlisting}[
	frame=none,
	basewidth={0.45em,0.4em},
	basicstyle=\ttfamily\footnotesize,breaklines=true,
	linewidth=0.98\columnwidth,xleftmargin=0.07\columnwidth,
	numbers=left,numberblanklines=true,numberstyle=\scriptsize\color{mylistingnclr}]
> ./ucvm2etree -f ./ucvm2etree_example.conf
\end{lstlisting}

Note that \texttt{ucvm2etree} is the basic serial version of other parallel (MPI) commands used to build large materialized models in high performance computer systems. Parallel tools for building etrees are useful because regional size simulations require models that can be of the order of hundreds of gigabytes to terabytes and can take significant time and resources to build. Thus, for large etrees, we strongly recommend using the \texttt{ucvm2etree-extract-MPI}, \texttt{ucvm2etree-sort-MPI}, and \texttt{ucvm2etree-merge-MPI} commands explained below.

\subsubsection{Other mesh and etree tools}

UCVM also provides other single-core serial commands to manipulate meshes and etrees. The additional mesh-related commands are: \texttt{mesh-check}, \texttt{mesh-op}, and \texttt{mesh-strip-ijk}. The command \texttt{mesh-check} does a basic quality assurance check of a mesh file. It checks that each record in the file is of the correct size makes sure that each value is not \texttt{NaN}, infinity, or negative. The command \texttt{mesh-op} subtracts a mesh from another mesh and outputs the difference. And the command \texttt{mesh-strip-ijk} converts an IJK-20 or IJK-32 mesh to an IJK-12 formatted mesh. Usage examples of each of these commands are shown next.

\begin{lstlisting}[
	frame=none,
	basewidth={0.45em,0.4em},
	basicstyle=\ttfamily\footnotesize,breaklines=true,
	linewidth=0.98\columnwidth,xleftmargin=0.07\columnwidth,
	numbers=left,numberblanklines=true,numberstyle=\scriptsize\color{mylistingnclr}]
> ./mesh-check new_mesh.mesh IJK-12
> ./mesh-op diff ./inmesh1 ./inmesh2 IJK-12 ./outmesh
> ./mesh-strip-ijk ijk20_mesh IJK-20 output_mesh
\end{lstlisting}

Additional etree manipulation commands include: \texttt{ecoalesce}, \texttt{ecompact} and \texttt{grd2etree}. The command \texttt{ecoalesce} aggregates octants in homogeneous regions. It helps compact the physical representation of an etree by replacing eight adjacent octants of the same size and properties with a single octant twice that preserves the same material properties (i.e., it replaces eight identical leaf octants at level $n$ by their parent octant at level $N-1$). The command \texttt{ecompact}, on the other hand, helps compact an etree by removing empty unused space in the etree data structure on disk, effectively reducing the file's size. The \texttt{ecompact} is usually run following the \texttt{ecoalsce}. The command \texttt{grd2etree} extracts an etree map (a one octant-thick etree with mapping information) from a set of DEM and \vsthirty{} grid files in ArcGIS Gridfloat format. This command is accompanied by the command \texttt{grd\_query}, which can be used to query data from ArcGIS grid files in GridFloat format. The following are usage examples of these commands.

\begin{lstlisting}[
	frame=none,
	basewidth={0.45em,0.4em},
	basicstyle=\ttfamily\footnotesize,breaklines=true,
	linewidth=0.98\columnwidth,xleftmargin=0.07\columnwidth,
	numbers=left,numberblanklines=true,numberstyle=\scriptsize\color{mylistingnclr}]
> ./ecoalesce original.etree coalesced.etree
> ./ecompact original.etree compacted.etree
> ./grd2etree -f ./grd2float_sample.conf
\end{lstlisting}

\subsection{MPI Commands}

As mentioned before, UCVM provides additional tools for accessing and manipulating CVMs using parallel applications that can be run in high-performance computer systems. These MPI commands provide the same basic operations of their equivalent single-core commands but provide the accelerated performance of parallelism. In general, these are all embarrassingly parallel processes and all the operations perform by each core are independent of each other. Interprocessor communications are limited to load distribution coordination at launch and collection of results at the end.

\subsubsection{The \textup{\texttt{basin\_query\_mpi}} command}

This command is the parallel version of \texttt{basin\_query}. It creates a binary float file listing the depths at which \vs{} crosses the user-defined threshold. The utility works by partitioning the points across the available processors, querying each point in parallel, and then amalgamating the results into one file. The command takes arguments preceded by flags for the output file, the UCVM configuration file, the velocity model to be used, the vertical step size (in meters), the threshold depth, the origin coordinates (in longitude and latitude), the horizontal gridding size (in degrees), and the number of grid points \textcolor{red}{to the east (x) and to the north (y)}. The following example outputs the data to \texttt{out.file} using the model \texttt{cvms} defined in the configuration file \texttt{ucvm.conf}. It queries each point at 20~m increments on the $z$-axis until reaching \vseq{1000} starting at longitude and latitude coordinates $-118\degree, 34\degree$, and then goes by 0.01\textdegree in both directions for 101 points to reach $-117\degree, 35\degree$.

\begin{lstlisting}[
	frame=none,
	basewidth={0.45em,0.4em},
	basicstyle=\ttfamily\footnotesize,breaklines=true,
	linewidth=0.98\columnwidth,xleftmargin=0.07\columnwidth,
	numbers=left,numberblanklines=true,numberstyle=\scriptsize\color{mylistingnclr}]
> mpirun -np 4 ./basin_query_mpi -b out.file -f ucvm.conf \
  -m cvms -i 20 -v 1000 -l 34,-118 -s 0.01 -x 101 -y 101
\end{lstlisting}

Note that in the example above, the call to \texttt{basin\_query\_mpi} is preceded by a call to \texttt{mpirun} and a request for 4 cores.

\subsubsection{The \textup{\texttt{ucvm2mesh-mpi}} command}

This tools is the parallel equivalent of \texttt{ucvm2mesh}, and can be used to generate meshes in either IJK-12, IJK-20, IJK-32, or SORD formats. In this case, unlike with \texttt{basin\_query\_mpi}, the arguments are passed on in the run configuration file.

\begin{lstlisting}[
	frame=none,
	basewidth={0.45em,0.4em},
	basicstyle=\ttfamily\footnotesize,breaklines=true,
	linewidth=0.98\columnwidth,xleftmargin=0.07\columnwidth,
	numbers=left,numberblanklines=true,numberstyle=\scriptsize\color{mylistingnclr}]
> mpirun -np 768 ucvm2mesh-mpi -f ./ucvm2mesh_example.conf
\end{lstlisting}

\subsubsection{The etree MPI commands}

The operations equivalent to the single-core command \texttt{ucvm2etree} are done by a set of three commands, \texttt{ucvm2etree-extract-MPI}, \texttt{ucvm2etree-sort-MPI} and \texttt{ucvm2etree-merge-MPI}. All three take as input the same run configuration-file and are executed in this order as shown in the following example:

\begin{lstlisting}[
	frame=none,
	basewidth={0.45em,0.4em},
	basicstyle=\ttfamily\footnotesize,breaklines=true,
	linewidth=0.98\columnwidth,xleftmargin=0.07\columnwidth,
	numbers=left,numberblanklines=true,numberstyle=\scriptsize\color{mylistingnclr}]
> mpirun -np 1025 ucvm2etree-extract-MPI \
  -f ./ucvm2etree_example.conf
> mpirun -np 1024 ucvm2etree-sort-MPI    \
  -f ./ucvm2etree_example.conf
> mpirun -np 1024 ucvm2etree-merge-MPI   \
  -f ./ucvm2etree_example.conf
\end{lstlisting}

Here, the first operation, \texttt{ucvm2etree-extract-MPI}, divides the etree region into a user-defined set of columns which are distributed to all processors. The rank-0 processor works as a dispatcher and farms out each column to all the other processors in a pool of $N$ cores. Each core queries the chosen CVM independently in an embarrassingly parallel process. Since the rank-0 processor does not participate of the extraction, \texttt{ucvm2etree-extract-MPI} requires $N+1$ processors. The output of this first step is a set of $N$ sub-etrees. Subsequently, \texttt{ucvm2etree-sort-MPI} sorts these sub-etrees so that each file is in local pre-order (following a $z$-order). Again, the is an embarrassingly parallel operation in which each rank reads in one of the sub-etrees produced by the previous operation and outputs its own sorted etree. Finally, \texttt{ucvm2etree-merge-MPI} merges $N$ locally sorted sub-etrees into a final, compacted etree.

\subsection{Configuration Files}

\textcolor{green}{I'd like to remove this subsection entirely as it is too detailed.}

In the sections above we made mention two two types of configuration files used by UCVM. The first of these files is the UCVM configuration file, which is automatically built in the easy installation process or should be prepared by the user in the advanced installation mode. This file is used by UCVM at runtime to identify which models have been pre-compiled and are ready to be used. This configuration file is used explicitly and must be passed as an argument to the commands \texttt{ucvm\_query} and \texttt{basin\_query}. An example of the file's format and content is shown in Figure \ref{fig:ucvm-config}. The mesh and etreee commands, on the other hand, use the UCVM configuration file implicitly and, instead, require a different type of configuration file to be passed as an argument, as it was shown in the examples above. In particular, \texttt{ucvm2mesh}, \texttt{ucvm2etree}, \texttt{./grd2etree}, and their equivalent MPI commands require the composition of this additional file. An example of this second configuration file is shown in Figure \ref{fig:run-config}. Other examples are available at: \textcolor{red}{give a valid URL, maybe reference Table \ref{tab:manuals} again}.

\input{figure-run-config}
